matrZ(importaciones_1,20,6)
sd2(importaciones_1[,1])
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
X0=reempNA(datos,n,p)
for (L in 0:100) {
VL=ACP_manual(X0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(X0,n,p,3,1)          #Componentes principales
X0=CL%*%VL                         #Reconstitucion de la matriz
}
result=list(VL,CL,X0)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
X0=reempNA(datos,n,p)
for (L in 0:100) {
VL=ACP_manual(X0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(X0,n,p,3,1)          #Componentes principales
ZL=CL%*%VL                         #Reconstitucion de la matriz estandarizada
for (i in 1:n) {
for (j in 1:p) {
X0[i,j]=ZL[i,j]*sd2(X0[,j])+mean(X0[,j])
}
}
retunr(X0)
}
result=list(VL,CL,X0)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
X0=reempNA(datos,n,p)
for (L in 0:100) {
VL=ACP_manual(X0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(X0,n,p,3,1)          #Componentes principales
ZL=CL%*%VL                         #Reconstitucion de la matriz estandarizada
for (i in 1:n) {
for (j in 1:p) {
X0[i,j]=ZL[i,j]*sd2(X0[,j])+mean(X0[,j])
}
}
return(X0)
}
result=list(VL,CL,X0)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
X0=reempNA(datos,n,p)
for (L in 0:100) {
VL=ACP_manual(X0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(X0,n,p,3,1)          #Componentes principales
ZL=CL%*%VL                         #Reconstitucion de la matriz estandarizada
for (i in 1:n) {
for (j in 1:p) {
X0[i,j]=ZL[i,j]*sd2(X0[,j])+mean(X0[,j])
}
}
}
result=list(VL,CL,ZL,X0)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
sd[importaciones[,1]]
sd(importaciones[,1])
sd2(importaciones[,1])
sd2(importaciones[,1])*(length(importaciones[,1]))
sd2(importaciones[,1])*(length(importaciones[,1]))
x<-c(1,2,3)
length(x)
length(importaciones[,1])
length(importaciones[,1])
sd2(importaciones[,1])*(length(importaciones[,1]))
length(importaciones[,1])
sd(importaciones[,1])*((length(importaciones[,1])-1))/(length(importaciones[,1]))
sd2(importaciones[,1])
(1-(1/length(importaciones[,1])))*sd(importaciones[,1])
sd(importaciones[,1])
(1-(1/length(importaciones[,1])))*sd2(importaciones[,1])
var(importaciones[,1])
(sd(importaciones[,1]))
(sd(importaciones[,1]))^2
x<-c(1,2,3)
sd(x)
sd2(x)
((3-2)/3)*sd(x)
((3-1)/3)*sd(x)
x<-c(1,2,3,4,5)
sd(x)
sd2(x)
(5/4)*sd2(x)
sd(x)
sqrt(4/5)*sd(x)
install.packages('plyr')
library('plyr')
count(importaciones_1[,1],vars = 'NA')
importaciones_1
count(importaciones_1[,1],vars = 'NA')+1
sqrt(count(importaciones_1[,1],vars = 'NA')+1)
sqrt(count(importaciones_1[,1],vars = 'NA')+1)$freq
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
X0=reempNA(datos,n,p)
for (L in 0:100) {
VL=ACP_manual(X0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(X0,n,p,3,1)          #Componentes principales
ZL=CL%*%VL                         #Reconstitucion de la matriz estandarizada
for (j in 1:p) {
for (i in 1:n) {
CNAcol=count(datos[,j],vars = 'NA')$freq
X0[i,j]=ZL[i,j]*(sqrt((n-CNAcol-1)/(n-CNAcol))*sd(datos[,j],na.rm = TRUE))+mean(datos[,j],na.rm = TRUE)
}
}
}
result=list(VL,CL,ZL,X0)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
x1 <- c(1.89,1.92,1.95,2.11,1.78,2.12,2.06,2.19,1.93,1.84)
x2 <- c(53,62,71,75,58,77,82,78,60,72)
x3 <- c(4.5,5.2,5.4,6.1,5,6.5,7.6,7.3,5.5,5.7)
x4 <- c(120,136,145,156,127,160,169,164,142,147)
X <- matrix(c(x1,x2,x3,x4),10,4)
importaciones_1
scale(importaciones_1)
reempNA(importaciones_1)
reempNA(importaciones_1,20,6)
matrZ(reempNA(importaciones_1,20,6),20,6)
scale(importaciones_1,center = TRUE,scale = TRUE)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
Z=scale(datos)
Z0=reempNA(Z,n,p)
for (L in 0:100) {
VL=ACP_manual(Z0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(Z0,n,p,3,1)          #Componentes principales
Z0=CL%*%VL                         #Reconstitucion de la matriz estandarizada
}
result=list(VL,CL,Z0,Z)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
ACP_manual(importaciones,20,6,3,1)
ACP_manual(scale(importaciones),20,6,3,1)
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
Z=scale(datos)
Z0=reempNA(Z,n,p)
for (L in 0:100) {
VL=ACP_manual(Z0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(Z0,n,p,3,1)          #Componentes principales
Z0=CL%*%t(VL)                         #Reconstitucion de la matriz estandarizada
}
result=list(VL,CL,Z0,Z)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Con la función de R
library(FactoMineR)
PCA(importaciones)
PCA(importaciones)$eig$vectors
eigen(importaciones)
eigen(cor(importaciones))
PCA(importaciones)
PCA(importaciones)$eig
eigen(cor(importaciones))$vectors
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
Z=scale(datos)
Z0=reempNA(Z,n,p)
for (L in 0:100) {
VL=eigen(cor(Z0))$vectors  #Matriz de vectores propios
CL=ACP_manual(Z0,n,p,3,1)          #Componentes principales
Z0=CL%*%t(VL)                         #Reconstitucion de la matriz estandarizada
}
result=list(VL,CL,Z0,Z)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
Z=scale(datos)
Z0=reempNA(Z,n,p)
for (L in 0:100) {
VL=ACP_manual(Z0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(Z0,n,p,3,1)          #Componentes principales
Z0=CL%*%t(VL)                         #Reconstitucion de la matriz estandarizada
}
result=list(VL,CL,Z0,Z)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
Z=scale(importaciones_1)
Z
Z0=reempNA(Z,20,6)
Z0
for (i in 1:3) {
Z0=Z0*2
}
Z0
Z=scale(importaciones_1)
Z0=reempNA(Z,20,6)
Z0
for (i in 1:100) {
Z0=Z0*2
}
Z0
eigen(cor(importaciones))
solve(eigen(cor(importaciones))$vectors)
planta<-c(1,2,3,4,5,6,7,8,9,10)
x1<-c(1.89,1.92,1.95,2.11,1.78,2.12,2.06,2.19,1.93,1.84)
x2<-c(53,62,71,75,58,77,82,78,60,72)
x3<-c(4.5,5.2,5.4,6.1,5,6.5,7.6,7.3,5.5,5.7)
x4<-c(120,136,145,156,127,160,169,164,142,147)
x<-matrix(c(x1,x2,x3,x4),10,4)
colnames(x)<-c("Altura planta","Longitud radicular","Área foliar","Peso pulpa")
#Función desviación estandar sobre n:
sd2 <- function (x) {
sqrt(sum((x - mean(x))^2) / (length(x)))
}
#--------------------------------------------------------------------------#
#Punto 1:
g<-c(mean(x1),mean(x2),mean(x3),mean(x4)) #Individuo (Planta) Promedio
#Inercia con los datos originales
s<-c()
for (i in 1:10) {
s[i]<-c((t(x[i,]-g))%*%(x[i,]-g))
}
ine<-sum(s)/10 #Inercia
#Inercia con datos centrados
#Centramos datos
X1<-(x1-mean(x1))
X2<-(x2-mean(x2))
X3<-(x3-mean(x3))
X4<-(x4-mean(x4))
X<-matrix(c(X1,X2,X3,X4),10,4)
colnames(X)<-c("Altura planta","Longitud radicular","Área foliar","Peso pulpa")
G<-c(mean(X1),mean(X2),mean(X3),mean(X4)) #Planta Promedio (Origen por datos centrados)
S<-c()
for (i in 1:10) {
S[i]<-c((t(X[i,]-G))%*%(X[i,]-G))
}
In<-sum(S)/10 #Inercia
#--------------------------------------------------------------------------#
#Punto 2:
#Estandarización:
z1 <- (x1 - mean(x1))/sd2(x1)
z2 <- (x2 - mean(x2))/sd2(x2)
z3 <- (x3 - mean(x3))/sd2(x3)
z4 <- (x4 - mean(x4))/sd2(x4)
#Matriz de datos estandarizada:
Z <- matrix(c(z1,z2,z3,z4),10,4)
gs<-c(mean(z1),mean(z2),mean(z3),mean(z4)) #Punto de gravedad con datos estandarizados
#Inercia con los datos estandarizados
ss<-c()
for (i in 1:10) {
ss[i]<-c((t(Z[i,]-gs))%*%(Z[i,]-gs))
}
Is<-sum(ss)/10 #Inercia (Como estan estandarizados debe ser igual al número de variables)
#--------------------------------------------------------------------------#
#Punto 3:
#Matriz de varianzas y covarianzas
V<-cov(x)
#--------------------------------------------------------------------------#
#Punto 4:
#Matriz de correlaciones
R<-cor(x)
#--------------------------------------------------------------------------#
#Punto 5:
#Matriz de varianzas y covarianzas:
dv <- eigen(V)  # Valores y Vectores propios de V
u <- dv$vectors
l <- dv$values
#Matriz de correlaciones:
dvR <- eigen(R)  # Valores y Vectores propios de R
uR <- dvR$vectors
lR <- dvR$values
#-------------------------------------------------------------------------#
#punto 8:
t<-x%*%u
t
Tz<-Z%*%uR
Tz
Tz%*%t(uR)
Z
#base de datos
importaciones=read.table("clipboard",header=T,row.names =1)
#base de datos
importaciones=read.table("clipboard",header=T,row.names =1)
N=length(importaciones$Colombia)*length(importaciones)#total de observaciones
N_1=N*0.05#numero de datos faltantes al 5%
N_2=N*0.1#numero de datos faltantes al 10%
N_3=N*0.15#numero de datos faltantes al 15%
N_4=N*0.2#numero de datos faltantes al 20%
#funcion (a)
remplazardatos=function(a,datos){
mustcol1=sample(c(1:6),a,replace = T)
mustrow1=sample(c(1:20),a,replace = T)
matr=datos
for(i in 1:a){
matr[mustrow1[i],mustcol1[i]]=NA
}
return(matr)
}
#matriz al 5%
importaciones_1=remplazardatos(N_1,importaciones)
#matriz al 10%
importaciones_2=remplazardatos(N_2,importaciones)
#matriz al 15%
importaciones_3=remplazardatos(N_3,importaciones)
#matriz al 20%
importaciones_4=remplazardatos(N_4,importaciones)
importaciones_4
#****Funciones manuales para ACP
# Función para sd (1/n)
sd2 <- function (x) {
sqrt(sum((x - mean(x))^2) / (length(x)))
}
#funcion para el calculo de la matriz Z
matrZ=function(datos,n,p){
datos
#Estandarización
Z=datos
for(i in 1:p){
Z[,i]=(Z[,i]-mean(Z[,i]))/sd2(Z[,i])
}
return(Z)
}
#funcion para el calculo del ACP
#ACP_manual la entrada l recibe los vaores 1,2 y 3
#para obtener 1:(correlacion) 2:(valores y vectores) 3:(componentes)
#la entrada tipo recibe valores 0:(VARIABES) 1:(INDIVIDUOS)
ACP_manual=function(datos,n,p,l,tipo){
Z=matrZ(datos,n,p)
if(tipo==1){
R=(t(Z)%*%as.matrix(Z))*(1/n)
dv=eigen(R)
CP=as.matrix(Z)%*%dv$vectors
}
if(tipo==0){
N=diag(sqrt(1/n),n,n)
R=N%*%as.matrix(Z)%*%t(Z)%*%N
dv=eigen(R)
CP=t(Z)%*%N%*%dv$vectors
}
if(l==1){
return(R)
}
if(l==2){
return(dv)
}
if(l==3){
return(CP)
}
}
#****ACP MANUAL DATOS COMPLETOS
#ACP (VARIABLES)
ACP_manual(importaciones,20,6,2,0) #valores y vectores propios
ACP_manual(importaciones,20,6,3,0) #componentes
#ACP (INDIVIDUOS)
ACP_manual(importaciones,20,6,2,1) #valores y vectores propios
ACP_manual(importaciones,20,6,3,1) #componentes
#****ACP MANUAL DATOS COMPLETOS (NIPALS)
#La entrada c recibe 0:(componentes principales) y 1:(vectores propios)
#la entrada tipo recibe valores 0:(VARIABES) 1:(INDIVIDUOS)
ACP_NIPALS=function(datos,n,p,c,tipo){
X=matrZ(datos,n,p)
if(tipo==1){
X0=X
T=matrix(NA,n,p)
P=matrix(NA,p,p)
}
if(tipo==0){
N=diag(sqrt(1/n),n,n)
X0=t(X)%*%N
T=matrix(NA,p,p)
P=matrix(NA,n,p)
}
for(h in 1:p){
t1=as.matrix(X0[,1])
for(i in 1:100){
P11=(t(X0)%*%t1)/(as.numeric(t(t1)%*%t1))
nP11=as.numeric(t(P11)%*%P11)
P1=1/sqrt(nP11)*P11
t1=as.matrix(X0)%*%P1
}
T[,h]=t1
P[,h]=P1
X1=X0-t1%*%t(P1)
X0=X1
}
if(c==1){
return(T)
}
if(c==0){
return(P)
}
}
#**ACP-NIPALS(INDIVIDUOS) MANUAL
P=ACP_NIPALS(importaciones,20,6,1,1) #componentes principales
T=ACP_NIPALS(importaciones,20,6,0,1) #vectores propios
valp=diag(t(P)%*%as.matrix(P)*(1/20)) #valores propios
#**ACP-NIPALS(VARIABLES) MANUAL
PV=ACP_NIPALS(importaciones,20,6,1,0) #componentes principales
TV=ACP_NIPALS(importaciones,20,6,0,0) #vectores propios
valpV=diag(t(PV)%*%as.matrix(PV)*(1/20)) #valores propios
#****ACP NO MANUAL (ADE4)
library(ade4)
#ACP MANUAL DATOS FALTANTES (NIPALS)
ACP_NIPALSNA=function(datos,n,p){
library("far")
njm=colMeans(datos,na.rm=TRUE); njs=colSums(datos,na.rm=TRUE)
nj=njs/njm
X=scale(datos)*sqrt(nj/(nj-1))
X0=X
P=matrix(NA,p,p); T=matrix(NA,n,p)
P1i=matrix(NA,p,1)
for(h in 1:p){
t1=X0[,1]
for(i in 1:100){
for(j in 1:p){
j1 =na.omit(cbind(X0[,j],t1))
P1i[j]=sum(j1[,1]*j1[,2])/sum(j1[,2]^2)
}
P[,h]=P1i
Portn=orthonormalization(P[,1:h]); P1=Portn[,h]
for(i in 1:n){
i1=na.omit(cbind(X0[i,],P1))
t1[i]=sum(i1[,1]*i1[,2])/sum(i1[,2]^2)
}
T[,h]=t1
Tortg=orthonormalization(T[,1:h],norm=FALSE); t1=Tortg[,h]
} # end i
P[,h]=P1
T[,h]=t1
X1=X0-t1%*%t(P1); X0=X1
} # end h
L=diag(t(T)%*%T)/n
r.nipNA=list(T,P,L); return(r.nipNA)
}
#**ACP martriz al 5%
ACP_NIPALSNA(importaciones_1,20,6)
#**ACP martriz al 10%
ACP_NIPALSNA(importaciones_2,20,6)
#**ACP martriz al 15%
ACP_NIPALSNA(importaciones_3,20,6)
#**ACP martriz al 20%
ACP_NIPALSNA(importaciones_4,20,6)
#--------------------------------------------------------#
#ACP EM
#FUNCIÓN PARA REEMPLAZAR DATOS FALTANTES POR VALORES INICIALES
reempNA=function(datos,n,p){
X0=datos
for (i in 1:p) {
for (j in 1:n) {
if(is.na(X0[j,i])=='TRUE'){
X0[j,i]=mean(X0[,i],na.rm = 'TRUE')
}
}
}
return(X0)
}
#Función algoritmo ACP EM
ACPEM=function(datos,n,p){
datos
L=0
Z=scale(datos)
Z0=reempNA(Z,n,p)
for (L in 0:100) {
VL=ACP_manual(Z0,n,p,2,1)$vectors  #Matriz de vectores propios
CL=ACP_manual(Z0,n,p,3,1)          #Componentes principales
Z0=CL%*%t(VL)                      #Reconstitucion de la matriz estandarizada
}
result=list(VL,CL,Z0,Z)
return(result)
}
#**ACP EM matriz al 5%
ACPEM(importaciones_1,20,6)
View(importaciones_1)
